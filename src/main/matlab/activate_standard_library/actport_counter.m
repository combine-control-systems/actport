% activate = 'system/SignalGenerators/Counter'
function model = actport_counter(model, block_id, model_path)
    import actport.model.Matlab.*

    name = get_name(model, block_id);
    block_path = sprintf('%s/%s', model_path, name);

    min = get_parameter(model, block_id, 'minim', '0');
    max = get_parameter(model, block_id, 'maxim', '4');
    step = get_parameter(model, block_id, 'step', '1');
    iout = get_parameter(model, block_id, 'Initv', '0');
    type = get_parameter(model, block_id, 'typ', '''double''');
    base = str2double(max) - str2double(min);
    if strcmp(get_parameter(model, block_id, 'rule', '''Increment'''), '''Increment''');
        rule = '+';
    else
        rule = '-';
    end

    % Simulink counter is too simple to reproduce Activate's counter. Using function block.
    add_block('simulink/User-Defined Functions/MATLAB Function', block_path);
    sf = sfroot();
    block = sf.find('Path', block_path, '-isa', 'Stateflow.EMChart');
    block.Script = sprintf([...
        'function y = f()\n'...
        '%%#codegen\n'...
        '   persistent count;\n'...
        '   if isempty(count)\n'...
        '       count = mod(%1$s, %2$d); %% Initial output, base\n'...
        '   else\n'...
        '       count = count %5$s %3$s; %% Rule, Step\n'...
        '       count = mod(count, %2$d); %% Base\n'...
        '   end\n'...
        '   aux = count + %3$s; %% Step\n'...
        '   y = cast(aux, %4$s);\n'...
        'end\n'...
    ], iout, base, step, type, rule);

    set_common_parameters(model, block_id, model_path);
end